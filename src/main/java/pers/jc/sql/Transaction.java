package pers.jc.sql;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.ArrayList;

public abstract class Transaction {
	private Connection connection;
	private ArrayList<PreparedStatement> preparedStatements = new ArrayList<>();
	private ArrayList<ResultSet> resultSets = new ArrayList<>();
	private boolean hasCommitted = false;
	
	public Transaction(Access access) {
		boolean error = false;
		try {
			connection = access.getConnection();
			connection.setAutoCommit(false);
			run();
		} catch (Exception e) {
			error = true;
			try {
				if (hasCommitted) {
					connection.rollback();
				}
			} catch (Exception e1) {
				e1.printStackTrace();
			}
			try {
				fail();
			} catch (Exception e2) {
				e2.printStackTrace();
			}
			e.printStackTrace();
		} finally {
			for (ResultSet resultSet : resultSets) {
				if (resultSet != null) {
					try {
						resultSet.close();
					} catch (Exception e) {
						e.printStackTrace();
					}
				}
			}
			for (PreparedStatement preparedStatement : preparedStatements) {
				if (preparedStatement != null) {
					try {
						preparedStatement.close();
					} catch (Exception e) {
						e.printStackTrace();
					}
				}
			}
			if (connection != null) {
				try {
					if (hasCommitted) {
						connection.setAutoCommit(true);
					} else {
						access.closeConnection(connection);
						connection = null;
					}
				} catch (Exception e) {
					access.closeConnection(connection);
					connection = null;
					e.printStackTrace();
				} finally {
					if (connection != null) {
						access.addToPool(connection);
					}
				}
			}
		}
		if (hasCommitted && !error) {
			try {
				success();
			} catch (Exception e) {
				e.printStackTrace();
			}
		} else if (!hasCommitted && !error) {
			try {
				cancel();
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}
	
	public abstract void run() throws Exception;

	/** run函数过程正常，且提交成功，则触发此函数 */
	public void success() {}

	/** run函数过程出错，可能还没来得及提交就出错了，则触发此函数 */
	public void fail() {}

	/** run函数过程正常，但没有主动提交，则触发此函数 */
	public void cancel() {}
		
	public void commit() throws Exception {
		this.hasCommitted = true;
		connection.commit();
	}
	
	public int insert(SQL sql) throws Exception {
		PreparedStatement preparedStatement = getPreparedStatement(sql, Statement.NO_GENERATED_KEYS);
		return preparedStatement.executeUpdate();
	}
	
	public int insertAndReturnKey(SQL sql) throws Exception {
		PreparedStatement preparedStatement = getPreparedStatement(sql, Statement.RETURN_GENERATED_KEYS);
		int key = 0;
		int count = preparedStatement.executeUpdate();
		if (count > 0) {
			ResultSet resultSet = preparedStatement.getGeneratedKeys();
			resultSets.add(resultSet);
			resultSet.next();
			key = resultSet.getInt(1);
		}
		return key;
	}
	
	public int update(SQL sql) throws Exception {
		PreparedStatement preparedStatement = getPreparedStatement(sql, Statement.NO_GENERATED_KEYS);
		return preparedStatement.executeUpdate();
	}
	
	public int delete(SQL sql) throws Exception {
		PreparedStatement preparedStatement = getPreparedStatement(sql, Statement.NO_GENERATED_KEYS);
		return preparedStatement.executeUpdate();
	}
	
	private PreparedStatement getPreparedStatement(SQL sql, int autoGeneratedKeys) throws Exception {
		PreparedStatement preparedStatement = connection.prepareStatement(sql.toString(), autoGeneratedKeys);
		preparedStatements.add(preparedStatement);
		return preparedStatement;
	}
	
	public <T> ArrayList<T> select(Class<T> modelClass, SQL sql) throws Exception {
		sql.SELECT_FROM(modelClass);
		return selectOperate(modelClass, sql.toString());
	}
	
	public <T> T selectOne(Class<T> modelClass, SQL sql) throws Exception {
		sql.SELECT_FROM(modelClass);
		sql.LIMIT("1");
		ArrayList<T> list = selectOperate(modelClass, sql.toString());
		if (list.size() > 0) {
			return list.get(0);
		} else {
			return null;
		}
	}
	
	public <T> ArrayList<T> selectAll(Class<T> modelClass) throws Exception {
		return selectOperate(modelClass, new SQL(){{
			SELECT_FROM(modelClass);
		}}.toString());
	}
	
	@SuppressWarnings("unchecked")
	public <T> int insert(T... models) throws Exception {
		return insertOperate(false, false, Statement.NO_GENERATED_KEYS, models);
	}

	@SuppressWarnings("unchecked")
	public <T> int insertIgnore(T... models) throws Exception {
		return insertOperate(true, false, Statement.NO_GENERATED_KEYS, models);
	}

	@SuppressWarnings("unchecked")
	public <T> int replace(T... models) throws Exception {
		return insertOperate(false, true, Statement.NO_GENERATED_KEYS, models);
	}

	@SuppressWarnings("unchecked")
	public <T> int insertAndGenerateKeys(T... models) throws Exception {
		return insertOperate(false, false, Statement.RETURN_GENERATED_KEYS, models);
	}

	@SuppressWarnings("unchecked")
	public <T> int insertIgnoreAndGenerateKeys(T... models) throws Exception {
		return insertOperate(true, false, Statement.RETURN_GENERATED_KEYS, models);
	}

	@SuppressWarnings("unchecked")
	public <T> int replaceAndGenerateKeys(T... models) throws Exception {
		return insertOperate(false, true, Statement.RETURN_GENERATED_KEYS, models);
	}

	@SuppressWarnings("unchecked")
	public <T> int update(T... models) throws Exception {
		return updateOperate(false, models);
	}

	@SuppressWarnings("unchecked")
	public <T> int updateIgnore(T... models) throws Exception {
		return updateOperate(true, models);
	}

	@SuppressWarnings("unchecked")
	public <T> int delete(T... models) throws Exception {
		return deleteOperate(false, models);
	}

	@SuppressWarnings("unchecked")
	public <T> int deleteIgnore(T... models) throws Exception {
		return deleteOperate(true, models);
	}

	private <T> ArrayList<T> selectOperate(Class<T> modelClass, String sql) throws Exception {
		ArrayList<T> list = new ArrayList<>();
		PreparedStatement preparedStatement = connection.prepareStatement(sql, Statement.NO_GENERATED_KEYS);
		preparedStatements.add(preparedStatement);
		ResultSet resultSet = preparedStatement.executeQuery();
		resultSets.add(resultSet);
		TableInfo tableInfo = Handle.getTableInfo(modelClass);
		while (resultSet.next()) {
			T model = modelClass.newInstance();
			for (FieldInfo fieldInfo : tableInfo.fieldInfos) {
				fieldInfo.setter.invoke(model, Handle.getResultSetValue(resultSet, fieldInfo.columnLabel, fieldInfo.type));
			}
			list.add(model);
		}
		return list;
	}

	@SuppressWarnings("unchecked")
	private <T> int insertOperate(boolean ignore, boolean replace, int autoGeneratedKeys, T... models) throws Exception {
		if (!Handle.isSameClass(models)) {
			return 0;
		}
		int updateCount = 0;
		TableInfo tableInfo = Handle.getTableInfo(models[0].getClass());
		SQL sql = new SQL(){{
			if (ignore) {
				IGNORE();
			} else if (replace) {
				REPLACE();
			}
			INSERT_INTO(tableInfo.tableName);
			for (FieldInfo fieldInfo : tableInfo.fieldInfos) {
				if (fieldInfo.isIdColumn && fieldInfo.autoIncrement) {
					continue;
				} else {
					VALUES(fieldInfo.columnLabel, "?");
				}
			}
		}};
		PreparedStatement preparedStatement = getPreparedStatement(sql, autoGeneratedKeys);
		for (T model : models) {
			int parameterIndex = 1;
			for (FieldInfo fieldInfo : tableInfo.fieldInfos) {
				if (fieldInfo.isIdColumn && fieldInfo.autoIncrement) {
					continue;
				} else {
					Object value = fieldInfo.getter.invoke(model, new Object[]{});
					Handle.setPreparedStatementValue(preparedStatement, parameterIndex, value);
					parameterIndex++;
				}
			}
			preparedStatement.addBatch();
		}
		int[] updateCounts = preparedStatement.executeBatch();
		for (int count : updateCounts) {
			updateCount += count;
		}
		if (autoGeneratedKeys == Statement.RETURN_GENERATED_KEYS) {
			ResultSet resultSet = preparedStatement.getGeneratedKeys();
			resultSets.add(resultSet);
			for (int i = 0; i < updateCounts.length; i++) {
				if (updateCounts[i] > 0) {
					resultSet.next();
					int key = resultSet.getInt(1);
					for (FieldInfo idInfo : tableInfo.idInfos) {
						if (idInfo.isIdColumn && idInfo.autoIncrement) {
							idInfo.setter.invoke(models[i], new Object[]{key});
							break;
						}
					}
				}
			}
		}
		return updateCount;
	}

	@SuppressWarnings("unchecked")
	private <T> int updateOperate(boolean ignore, T... models) throws Exception {
		if (!Handle.isSameClass(models)) {
			return 0;
		}
		int updateCount = 0;
		TableInfo tableInfo = Handle.getTableInfo(models[0].getClass());
		if (tableInfo.idInfos.isEmpty()) {
			throw new Exception();
		}
		SQL sql = new SQL(){{
			if (ignore) {
				IGNORE();
			}
			UPDATE(tableInfo.tableName);
			for (FieldInfo fieldInfo : tableInfo.fieldInfos) {
				if (fieldInfo.isIdColumn) {
					continue;
				} else {
					SET(fieldInfo.columnLabel + " = ?");
				}
			}
			for (FieldInfo idInfo : tableInfo.idInfos) {
				WHERE(idInfo.columnLabel + " = ?");
			}
		}};
		PreparedStatement preparedStatement = getPreparedStatement(sql, Statement.NO_GENERATED_KEYS);
		for (T model : models) {
			int parameterIndex = 1;
			for (FieldInfo fieldInfo : tableInfo.fieldInfos){
				if (fieldInfo.isIdColumn) {
					continue;
				} else {
					Object value = fieldInfo.getter.invoke(model, new Object[]{});
					Handle.setPreparedStatementValue(preparedStatement, parameterIndex, value);
					parameterIndex++;
				}
			}
			for (FieldInfo idInfo : tableInfo.idInfos) {
				Object id = idInfo.getter.invoke(model, new Object[]{});
				Handle.setPreparedStatementValue(preparedStatement, parameterIndex, id);
				parameterIndex++;
			}
			preparedStatement.addBatch();
		}
		int[] updateCounts = preparedStatement.executeBatch();
		for (int count : updateCounts) {
			updateCount += count;
		}
		return updateCount;
	}

	@SuppressWarnings("unchecked")
	private <T> int deleteOperate(boolean ignore, T... models) throws Exception {
		if (!Handle.isSameClass(models)) {
			return 0;
		}
		int updateCount = 0;
		TableInfo tableInfo = Handle.getTableInfo(models[0].getClass());
		if (tableInfo.idInfos.isEmpty()) {
			throw new Exception();
		}
		SQL sql = new SQL(){{
			if (ignore) {
				IGNORE();
			}
			DELETE_FROM(tableInfo.tableName);
			for (FieldInfo idInfo : tableInfo.idInfos) {
				WHERE(idInfo.columnLabel + " = ?");
			}
		}};
		PreparedStatement preparedStatement = getPreparedStatement(sql, Statement.NO_GENERATED_KEYS);
		for (T model : models) {
			int parameterIndex = 1;
			for (FieldInfo idInfo : tableInfo.idInfos) {
				Object id = idInfo.getter.invoke(model, new Object[]{});
				Handle.setPreparedStatementValue(preparedStatement, parameterIndex, id);
				parameterIndex++;
			}
			preparedStatement.addBatch();
		}
		int[] updateCounts = preparedStatement.executeBatch();
		for (int count : updateCounts) {
			updateCount += count;
		}
		return updateCount;
	}
}
